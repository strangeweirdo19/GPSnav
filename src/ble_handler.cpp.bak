#include "common.h"
// ble_handler.cpp
#include "ble_handler.h"
#include <WiFi.h>
#include <HTTPUpdate.h>
#include <HTTPClient.h>
#include <mbedtls/base64.h>
#include <SD_MMC.h>
#include <FS.h>
#include <esp_task_wdt.h>
#include <Preferences.h>
#include <nvs_flash.h>

Preferences preferences;
String currentClientAddress = "";
uint16_t currentConnHandle = 0xFFFF; // Store current connection handle
String currentSessionToken = ""; // Store current session token for unpairing

// Global instance
BLEHandler bleHandler;

// Initialize static instance pointer
BLEHandler* BLEHandler::instance = nullptr;

// Server callbacks for connection events
class ServerCallbacks: public NimBLEServerCallbacks {
    void onConnect(NimBLEServer* pServer, NimBLEConnInfo& connInfo) {
        Serial.println("");
        Serial.println("================================================");
        Serial.println("  BLE CLIENT CONNECTED!");
        Serial.println("================================================");
        
        // Store current address and connection handle globally
        std::string addrStr = connInfo.getAddress().toString();
        currentClientAddress = String(addrStr.c_str());
        currentConnHandle = connInfo.getConnHandle();
        
        // SECURITY: If pairing window closed, only allow whitelisted devices
        if (BLEHandler::instance && !BLEHandler::instance->isWithinPairingWindow()) {
            // Check blacklist
            if (BLEHandler::instance->isBlacklisted(connInfo.getAddress())) {
                Serial.printf("[SECURITY] Pairing window closed - rejecting blacklisted device: %s\n", 
                              connInfo.getAddress().toString().c_str());
                pServer->disconnect(connInfo.getConnHandle());
                return;
            }
            
            Serial.printf("[SECURITY] Pairing window closed - allowing connection attempt from: %s (will verify token)\n",
                          connInfo.getAddress().toString().c_str());
        }
        
        // ZERO TRUST MODEL: Always accept connection provisionally and wait for Token
        Serial.println("  STATUS: Connection Accepted (Provisional)");
        Serial.println("  Auth: Waiting for Token (1s)...");
        
        bleHandler.waitingForToken = true;
        bleHandler.authStartTime = millis();
        
        bleHandler.resetAuthState();
        bleHandler.sendNotification("AUTH_REQ");
        // Do NOT call onDeviceConnected yet (keeps PIN hidden)
    }

    void onDisconnect(NimBLEServer* pServer, NimBLEConnInfo& connInfo) {
        Serial.println("BLE: Client disconnected");
        currentClientAddress = "";
        currentConnHandle = 0xFFFF;
        bleHandler.resetAuthState();
        // Trigger callback to update status
        if (bleHandler.onDeviceDisconnected) {
            bleHandler.onDeviceDisconnected();
        }
        NimBLEDevice::startAdvertising();
        Serial.println("BLE: Advertising restarted");
    }
};

// RX Characteristic callbacks for receiving data
class RxCallbacks: public NimBLECharacteristicCallbacks {
    void onWrite(NimBLECharacteristic* pCharacteristic) {
        Serial.println("[DEBUG] RX Callback TRIGGERED!");  // First thing - proves callback fires
        
        std::string value = pCharacteristic->getValue();
        Serial.print("[DEBUG] Raw length: ");
        Serial.println(value.length());
        
        if (value.length() > 0) {
            String receivedData = String(value.c_str());
            Serial.println("");
            Serial.println("================================================");
            Serial.print("BLE RX: Received ");
            Serial.print(receivedData.length());
            Serial.println(" bytes");
            Serial.print("BLE RX: Data: '");
            Serial.print(receivedData);
            Serial.println("'");
            Serial.println("================================================");
            bleHandler.parseReceivedData(receivedData);
        } else {
            Serial.println("BLE RX: WARNING - Empty data received");
        }
    }
};

// Constructor
BLEHandler::BLEHandler() 
    : pServer(nullptr), pTxCharacteristic(nullptr), pRxCharacteristic(nullptr),
      isAuthenticated(false), authAttempts(0), lockoutUntil(0), lastActivityTime(0),
      bootTime(0), waitingForToken(false), authStartTime(0), blacklistCount(0) {
    // Set static instance pointer for callback access
    instance = this;
}

// Generate unique device name from MAC address
void BLEHandler::generateDeviceName() {
    uint8_t mac[6];
    esp_read_mac(mac, ESP_MAC_BT);
    char suffix[5];
    snprintf(suffix, sizeof(suffix), "%02X%02X", mac[4], mac[5]);
    deviceName = "Navion-HUD-" + String(suffix);
}

// Generate random 6-digit PIN
void BLEHandler::generatePIN() {
    devicePIN = "";
    for (int i = 0; i < 3; i++) {
        devicePIN += String(random(0, 10));
    }
    Serial.println("===========================================");
    Serial.printf("    BLE PIN: %s\n", devicePIN.c_str());
    Serial.println("===========================================");
}

// ===== TOKEN BUFFER MANAGEMENT =====
#define MAX_TOKENS 10

bool BLEHandler::addToken(const String& token) {
    preferences.begin("ble-bonds", false);
    int count = preferences.getInt("token_count", 0);
    
    // Check if token already exists
    for (int i = 0; i < count; i++) {
        String key = "token_" + String(i);
        String existing = preferences.getString(key.c_str(), "");
        if (existing == token) {
            // Update timestamp for existing token
            String tsKey = "token_" + String(i) + "_ts";
            preferences.putULong(tsKey.c_str(), millis());
            preferences.end();
            Serial.println("BLE: Token already exists, updated timestamp");
            return true;
        }
    }
    
    // If buffer full, evict oldest (LRU)
    if (count >= MAX_TOKENS) {
        Serial.println("BLE: Token buffer full, evicting LRU");
        unsigned long oldestTime = ULONG_MAX;
        int oldestIndex = 0;
        
        for (int i = 0; i < count; i++) {
            String tsKey = "token_" + String(i) + "_ts";
            unsigned long ts = preferences.getULong(tsKey.c_str(), 0);
            if (ts < oldestTime) {
                oldestTime = ts;
                oldestIndex = i;
            }
        }
        
        // Overwrite oldest slot
        String key = "token_" + String(oldestIndex);
        String tsKey = "token_" + String(oldestIndex) + "_ts";
        preferences.putString(key.c_str(), token);
        preferences.putULong(tsKey.c_str(), millis());
    } else {
        // Add new token
        String key = "token_" + String(count);
        String tsKey = "token_" + String(count) + "_ts";
        preferences.putString(key.c_str(), token);
        preferences.putULong(tsKey.c_str(), millis());
        preferences.putInt("token_count", count + 1);
    }
    
    preferences.end();
    Serial.printf("BLE: Token added to buffer (count: %d)\n", min(count + 1, MAX_TOKENS));
    return true;
}

bool BLEHandler::isValidToken(const String& token) {
    if (token.length() < 15) return false;
    
    preferences.begin("ble-bonds", true);
    int count = preferences.getInt("token_count", 0);
    
    for (int i = 0; i < count; i++) {
        String key = "token_" + String(i);
        String stored = preferences.getString(key.c_str(), "");
        if (stored == token) {
            // Update timestamp
            preferences.end();
            preferences.begin("ble-bonds", false);
            String tsKey = "token_" + String(i) + "_ts";
            preferences.putULong(tsKey.c_str(), millis());
            preferences.end();
            return true;
        }
    }
    
    preferences.end();
    return false;
}

void BLEHandler::removeToken(const String& token) {
    preferences.begin("ble-bonds", false);
    int count = preferences.getInt("token_count", 0);
    
    for (int i = 0; i < count; i++) {
        String key = "token_" + String(i);
        String stored = preferences.getString(key.c_str(), "");
        if (stored == token) {
            // Shift remaining tokens down
            for (int j = i; j < count - 1; j++) {
                String srcKey = "token_" + String(j + 1);
                String srcTsKey = "token_" + String(j + 1) + "_ts";
                String dstKey = "token_" + String(j);
                String dstTsKey = "token_" + String(j) + "_ts";
                
                String tokenVal = preferences.getString(srcKey.c_str(), "");
                unsigned long tsVal = preferences.getULong(srcTsKey.c_str(), 0);
                
                preferences.putString(dstKey.c_str(), tokenVal);
                preferences.putULong(dstTsKey.c_str(), tsVal);
            }
            
            // Remove last slot
            String lastKey = "token_" + String(count - 1);
            String lastTsKey = "token_" + String(count - 1) + "_ts";
            preferences.remove(lastKey.c_str());
            preferences.remove(lastTsKey.c_str());
            
            preferences.putInt("token_count", count - 1);
            Serial.printf("BLE: Token removed from buffer (count: %d)\n", count - 1);
            break;
        }
    }
    
    preferences.end();
}

// Centralized connection auth decision
void BLEHandler::handleConnectionAuth(const String& token, bool hasToken) {
    if (hasToken && isValidToken(token)) {
        // Valid token -> Authenticate
        isAuthenticated = true;
        authAttempts = 0;
        waitingForToken = false;
        authStartTime = 0;
        currentSessionToken = token; // Track active token
        Serial.println("BLE: Token Valid - Authenticated!");
        sendNotification("AUTH_OK");
        // Report GPS status
        sendNotification(gpsModulePresent ? "GPS_STATUS: 1" : "GPS_STATUS: 0");
        if (onAuthenticated) onAuthenticated();
    } else if (hasToken && !isValidToken(token)) {
        // Invalid token -> Report to app and show PIN or disconnect
        Serial.println("BLE: Invalid Token Detected");
        String tokenPrefix = token.substring(0, min(15, (int)token.length()));
        sendNotification("TOKEN_INVALID " + tokenPrefix);
        waitingForToken = false;
        
        if (isWithinPairingWindow()) {
            Serial.println("BLE: Window Open -> Showing PIN");
            sendNotification("AUTH_FAIL");
            if (onDeviceConnected) onDeviceConnected();
        } else {
            Serial.println("BLE: Window Closed -> Disconnecting");
            sendNotification("PAIRING_CLOSED");
            if (currentConnHandle != 0xFFFF && pServer) {
                pServer->disconnect(currentConnHandle);
            }
        }
    } else {
        // No token provided
        waitingForToken = false;
        
        // BIDIRECTIONAL SYNC: Check if we have saved tokens
        // If yes, it means the app unpaired us, so we should forget them too
        preferences.begin("ble-bonds", false);
        int tokenCount = preferences.getInt("token_count", 0);
        
        if (tokenCount > 0) {
            Serial.printf("[SYNC] App sent AUTH_NONE but we have %d tokens. App likely unpaired us.\n", tokenCount);
            Serial.println("[SYNC] Clearing our token buffer to stay in sync with app");
            
            // Clear the entire token buffer
            preferences.clear();
            Serial.println("[SYNC] Token buffer cleared - both sides now unpaired");
        }
        preferences.end();
        
        if (isWithinPairingWindow()) {
            Serial.println("BLE: No Token, Window Open -> Showing PIN");
            if (onDeviceConnected) onDeviceConnected();
        } else {
            Serial.println("BLE: No Token, Window Closed -> Disconnecting");
            
            // Add to blacklist before disconnecting
            if (pServer && pServer->getConnectedCount() > 0) {
                NimBLEConnInfo connInfo = pServer->getPeerInfo(0);
                addToBlacklist(connInfo.getAddress());
            }
            
            sendNotification("PAIRING_CLOSED");
            Serial.println("[PAIRING] Window CLOSED - only bonded devices can connect");
            if (currentConnHandle != 0xFFFF && pServer) {
                pServer->disconnect(currentConnHandle);
            }
        }
    }
}

// ===== BLACKLIST MANAGEMENT =====

void BLEHandler::addToBlacklist(NimBLEAddress addr) {
    // Check if already blacklisted
    for (int i = 0; i < blacklistCount; i++) {
        if (blacklistedDevices[i] == addr) {
            Serial.println("[BLACKLIST] Device already blacklisted");
            return;
        }
    }
    
    // Add to blacklist (circular buffer)
    if (blacklistCount < MAX_BLACKLISTED) {
        blacklistedDevices[blacklistCount++] = addr;
    } else {
        // Overwrite oldest (index 0), shift array
        for (int i = 0; i < MAX_BLACKLISTED - 1; i++) {
            blacklistedDevices[i] = blacklistedDevices[i + 1];
        }
        blacklistedDevices[MAX_BLACKLISTED - 1] = addr;
    }
    
    Serial.printf("[BLACKLIST] Added device: %s (count: %d)\n", 
                  addr.toString().c_str(), blacklistCount);
}

bool BLEHandler::isBlacklisted(NimBLEAddress addr) {
    for (int i = 0; i < blacklistCount; i++) {
        if (blacklistedDevices[i] == addr) {
            return true;
        }
    }
    return false;
}

// Get device name
String BLEHandler::getDeviceName() {
    return deviceName;
}

// Get current PIN
String BLEHandler::getPIN() {
    return devicePIN;
}

// Validate PIN
bool BLEHandler::validatePIN(const String& pin) {
    return pin == devicePIN;
}

// Reset authentication state
void BLEHandler::resetAuthState() {
    isAuthenticated = false;
    authAttempts = 0;
    lastActivityTime = millis();
    waitingForToken = false;
    authStartTime = 0;
    currentSessionToken = ""; // Clear session token
}

// Check session timeout
bool BLEHandler::checkSessionTimeout() {
    if (isAuthenticated && (millis() - lastActivityTime > SESSION_TIMEOUT_MS)) {
        Serial.println("BLE: Session timeout - re-authentication required");
        isAuthenticated = false;
        sendNotification("SESSION_TIMEOUT");
        return true;
    }
    return false;
}

// Check if within pairing window (first 60 seconds after boot)
bool BLEHandler::isWithinPairingWindow() {
    return (millis() - bootTime) < PAIRING_WINDOW_MS;
}

// Get count of bonded devices
int BLEHandler::getBondedDeviceCount() {
    return NimBLEDevice::getNumBonds();
}

// Get list of bonded devices as JSON array
String BLEHandler::getBondedDevicesList() {
    int bondCount = NimBLEDevice::getNumBonds();
    
    if (bondCount == 0) {
        return "[]";
    }
    
    // Build JSON array by iterating through bonded addresses
    String json = "[";
    int addedCount = 0;
    
    // NimBLE doesn't have getBondedDevices, so we report count only
    // or iterate through peer info if available
    for (int i = 0; i < bondCount; i++) {
        if (addedCount > 0) json += ",";
        // Note: NimBLE doesn't expose easy access to bonded addresses list
        // We'll return simplified info for now
        json += "{\"index\":" + String(i) + "}";
        addedCount++;
    }
    json += "]";
    
    return json;
}

// Clear all bonding data
bool BLEHandler::clearAllBonds() {
    Serial.println("BLE: Clearing all bonding data");
    NimBLEDevice::deleteAllBonds();
    
    // Clear custom whitelist
    preferences.begin("ble-bonds", false);
    preferences.clear();
    preferences.end();
    
    Serial.println("BLE: All bonds cleared successfully");
    return true;
}

// Remove specific bonded device by address
bool BLEHandler::removeBond(const String& address) {
    Serial.printf("BLE: Removing bond for device: %s\n", address.c_str());
    NimBLEAddress addr(address.c_str());
    int result = NimBLEDevice::deleteBond(addr);
    
    // Always remove from custom whitelist regardless of native bond result
    String macKey = address;
    macKey.replace(":", "");
    preferences.begin("ble-bonds", false);
    preferences.remove(macKey.c_str());
    preferences.end();
    
    if (result == 0 || true) { // Assume success if we cleared custom
        Serial.println("BLE: Bond removed successfully");
        return true;
    } else {
        Serial.printf("BLE: Failed to remove bond, error: %d\n", result);
        return false;
    }
}

// Validate input to prevent buffer overflow and malicious data
bool BLEHandler::validateInput(const String& data) {
    if (data.length() > 512) {
        Serial.println("BLE: Input validation failed - too long");
        return false;
    }
    // Check for null bytes
    if (data.indexOf('\0') >= 0 && data.indexOf('\0') < data.length() - 1) {
        Serial.println("BLE: Input validation failed - null byte detected");
        return false;
    }
    return true;
}

// Initialize BLE
void BLEHandler::init() {
    // Initialize NVS
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
      ESP_ERROR_CHECK(nvs_flash_erase());
      ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    // Debug: Dump stored tokens
    preferences.begin("ble-bonds", true); // Read-only
    int count = preferences.getInt("token_count", 0);
    Serial.printf("BLE: Init - Found %d stored tokens in NVS\n", count);
    for(int i=0; i<count; i++) {
        String key = "token_" + String(i);
        String t = preferences.getString(key.c_str(), "MISSING");
        Serial.printf("  Token[%d]: %s...\n", i, t.substring(0, 5).c_str());
    }
    preferences.end();

    Serial.println("BLE: Initializing NimBLE...");
    
    // Record boot time for pairing window
    bootTime = millis();
    
    // Generate unique device name and PIN
    generateDeviceName();
    generatePIN();
    
    // Create the BLE Device
    NimBLEDevice::init(deviceName.c_str());
    NimBLEDevice::setMTU(512);

    // NUCLEAR CLEANUP: Delete all existing bonds to prevent legacy security
    NimBLEDevice::deleteAllBonds();
    
    // Security: Disable bonding and secure connections to prevent OS pairing dialogs
    // We are handling our own custom application-layer authentication
    NimBLEDevice::setSecurityAuth(false, false, false); 
    NimBLEDevice::setSecurityIOCap(BLE_HS_IO_NO_INPUT_OUTPUT); 
    // NUCLEAR OPTION for iOS: Explicitly say "We have NO keys to exchange"
    // This stops the phone from even asking "Would you like to pair?"
    NimBLEDevice::setSecurityInitKey(0);
    NimBLEDevice::setSecurityRespKey(0); 
    
    Serial.println("BLE: Pairing window active for 60 seconds");
    Serial.println("");
    Serial.println("================================================");
    Serial.print("  PAIRING WINDOW: ");
    Serial.print(PAIRING_WINDOW_MS / 1000);
    Serial.println(" seconds from boot");
    Serial.println("  New devices can only pair during this time!");
    Serial.println("================================================");
    Serial.println("");
    
    // Create the BLE Server
    pServer = NimBLEDevice::createServer();
    pServer->setCallbacks(new ServerCallbacks());
    
    // Create the BLE Service
    NimBLEService* pService = pServer->createService(SERVICE_UUID);
    
    // Create the TX Characteristic (ESP32 -> App, Notify)
    pTxCharacteristic = pService->createCharacteristic(
        TX_CHARACTERISTIC_UUID,
        NIMBLE_PROPERTY::READ | NIMBLE_PROPERTY::NOTIFY
    );
    
    // Create the RX Characteristic (App -> ESP32, Write)
    pRxCharacteristic = pService->createCharacteristic(
        RX_CHARACTERISTIC_UUID,
        NIMBLE_PROPERTY::WRITE | NIMBLE_PROPERTY::WRITE_NR
    );
    pRxCharacteristic->setCallbacks(new RxCallbacks());
    
    // Start the service
    pService->start();
    
    // Start advertising
    NimBLEAdvertising* pAdvertising = NimBLEDevice::getAdvertising();
    pAdvertising->addServiceUUID(SERVICE_UUID);
    pAdvertising->setScanResponse(true);
    pAdvertising->setMinPreferred(0x06);
    pAdvertising->setMaxPreferred(0x12);
    
    // Start advertising with Pairing Open status
    updateAdvertising(true);
    Serial.printf("BLE: Service started. Device name: %s\n", deviceName.c_str());
    Serial.println("BLE: Waiting for client connection...");
}

// Update advertising data with pairing status
void BLEHandler::updateAdvertising(bool pairingOpen) {
    NimBLEAdvertising* pAdvertising = NimBLEDevice::getAdvertising();
    pAdvertising->stop(); // Stop before updating
    
    // Set Service Data: 0x01 = Pairing Open, 0x00 = Pairing Closed
    std::string serviceData;
    serviceData.push_back(pairingOpen ? 0x01 : 0x00);
    
    // We must set service data for our specific service UUID
    pAdvertising->setServiceData(NimBLEUUID(SERVICE_UUID), serviceData);
    
    pAdvertising->start();
    Serial.printf("BLE: Advertising updated. Pairing Mode: %s\n", pairingOpen ? "OPEN" : "CLOSED");
}

// Loop function - call from main loop
void BLEHandler::loop() {
    static unsigned long lastStatusCheck = 0;
    static bool wasConnected = false;
    static bool wasPairingOpen = true; // Track previous state
    
    // Check for silent auth timeout
    if (waitingForToken) {
        if (millis() - authStartTime > 1000) { // 1 second timeout
            Serial.println("BLE: Silent Auth Timeout - Using centralized logic");
            handleConnectionAuth("", false);
        }
    }
    
    // Check session timeout
    checkSessionTimeout();
    
    // Check pairing window transition (approximate)
    bool isPairingOpen = isWithinPairingWindow();
    if (isPairingOpen != wasPairingOpen) {
        // State changed!
        updateAdvertising(isPairingOpen);
        wasPairingOpen = isPairingOpen;
    }
    
    // Check connection status frequently (every 500ms) for instant feedback
    if (millis() - lastStatusCheck >= 500) {
        lastStatusCheck = millis();

        bool connected = isConnected();
        
        // Report connection status change
        if (connected != wasConnected) {
            if (connected) {
                Serial.println("\n[STATUS] BLE Link Established (Auth Required)");
                // Do NOT trigger callbacks here - let handshake complete first
            } else {
                Serial.println("\n[STATUS] BLE device is DISCONNECTED - waiting for connection...");
                if (onDeviceDisconnected) {
                     onDeviceDisconnected();
                }
            }
            wasConnected = connected;
        }
        
        // Report pairing window status if not connected
        if (!connected) {
            unsigned long elapsed = (millis() - bootTime) / 1000;
            if (isWithinPairingWindow()) {
                Serial.print("[PAIRING] Window OPEN - ");
                Serial.print((PAIRING_WINDOW_MS / 1000) - elapsed);
                Serial.println(" seconds remaining for new devices");
            } else {
                Serial.println("[PAIRING] Window CLOSED - only bonded devices can connect");
            }
        }
        
        lastStatusCheck = millis();
    }
}

// Check if a device is connected
bool BLEHandler::isConnected() {
    return pServer->getConnectedCount() > 0;
}

// Check if device is authenticated
bool BLEHandler::isDeviceAuthenticated() {
    return isAuthenticated;
}

// Base64 encode function using mbedtls
String BLEHandler::base64Encode(const String& input) {
    size_t outputLen = 0;
    
    int ret = mbedtls_base64_encode(nullptr, 0, &outputLen, 
                                     (const unsigned char*)input.c_str(), 
                                     input.length());
    
    if (ret == MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL) {
        unsigned char* buffer = new unsigned char[outputLen];
        
        ret = mbedtls_base64_encode(buffer, outputLen, &outputLen,
                                    (const unsigned char*)input.c_str(),
                                    input.length());
        
        if (ret == 0) {
            String result = String((char*)buffer);
            delete[] buffer;
            return result;
        }
        delete[] buffer;
    }
    
    Serial.println("BLE: Base64 encoding failed");
    return "";
}

// Send notification to connected client (Plain Text)
void BLEHandler::sendNotification(const String& message) {
    if (isConnected()) {
        // Send plain text. Mobile app handles decoding from BLE bytes.
        // Prevent double-encoding or malloc issues.
        pTxCharacteristic->setValue((const uint8_t*)message.c_str(), message.length());
        pTxCharacteristic->notify();
        Serial.printf("BLE TX: Sent: %s\n", message.c_str());
    } else {
        Serial.println("BLE TX: No device connected");
    }
}

// Parse received data and route to appropriate handlers
void BLEHandler::parseReceivedData(const String& data) {
    // Validate input
    if (!validateInput(data)) {
        Serial.println("BLE: Input validation FAILED");
        sendNotification("ERROR_INVALID_INPUT");
        return;
    }
    
    String trimmedData = data;
    trimmedData.trim();
    
    Serial.print("BLE: Parsing command: '");
    Serial.print(trimmedData);
    Serial.println("'");
    
    // Update activity timestamp
    lastActivityTime = millis();
    
    // Check if locked out
    if (millis() < lockoutUntil) {
        Serial.println("BLE: Device is LOCKED OUT");
        sendNotification("AUTH_LOCKED");
        return;
    }
    
    // Handle PIN authentication
    if (trimmedData.startsWith("PIN ")) {
        String pin = trimmedData.substring(4);
        pin.trim();
        
        // CRITICAL: Check pairing window before accepting PIN
        if (!isWithinPairingWindow()) {
            Serial.println("BLE: PIN attempt REJECTED - Pairing window CLOSED");
            sendNotification("PAIRING_CLOSED");
            // Disconnect immediately
            if (currentConnHandle != 0xFFFF && pServer) {
                pServer->disconnect(currentConnHandle);
            }
            return;
        }
        
        if (validatePIN(pin)) {
            isAuthenticated = true;
            authAttempts = 0;
            Serial.println("");
            Serial.println("================================================");
            Serial.println("  ✓ AUTHENTICATION SUCCESSFUL");
            Serial.println("  Device is now authenticated and can send commands");
            Serial.println("================================================");
            Serial.println("");
            sendNotification("AUTH_OK");
            // Report GPS status
            sendNotification(gpsModulePresent ? "GPS_STATUS: 1" : "GPS_STATUS: 0");
            
            // Generate and Save Auth Token (Rolling Buffer)
            if (currentClientAddress.length() > 0) {
                // Generate simple random token
                String token = "";
                for(int i=0; i<16; i++) {
                    token += String("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")[random(0, 62)];
                }
                
                // Add to rolling buffer (max 10, LRU eviction)
                addToken(token);
                
                // Track active token for unpairing
                currentSessionToken = token;
                
                Serial.println("  TRUSTED: Token added to buffer");
                
                // Send Token to Client
                sendNotification("TOKEN " + token);
            }

            // Trigger callback to clear PIN display
            if (onAuthenticated) {
                onAuthenticated();
            }
            return;
        } else {
            authAttempts++;
            Serial.println("");
            Serial.println("================================================");
            Serial.println("  ✗ AUTHENTICATION FAILED");
            Serial.printf("  Wrong PIN! Attempt %d of %d\n", authAttempts, MAX_AUTH_ATTEMPTS);
            Serial.print("  Correct PIN: ");
            Serial.println(getPIN());
            Serial.println("================================================");
            Serial.println("");
            
            if (authAttempts >= MAX_AUTH_ATTEMPTS) {
                lockoutUntil = millis() + AUTH_LOCKOUT_TIME_MS;
                Serial.println("BLE: Max auth attempts reached - locking out");
                sendNotification("AUTH_LOCKED");
                // Disconnect the client - DISABLED to allow UI feedback
                // pServer->disconnect(pServer->getPeerInfo(0).getConnHandle());
            } else {
                sendNotification("AUTH_FAIL");
            }
        }
        return;
    }

    // Handle Token Authentication - Use centralized logic
    if (trimmedData.startsWith("AUTH_TOKEN ")) {
        String token = trimmedData.substring(11);
        token.trim();
        handleConnectionAuth(token, true);
        return;
    }

    // Handle AUTH_NONE (Client has no token) - Use centralized logic
    if (trimmedData == "AUTH_NONE") {
         Serial.println("BLE: Client sent AUTH_NONE");
         handleConnectionAuth("", false);
         return;
    }
    
    // Check for FW_MD5 (Allowed without Auth)
    if (trimmedData == "FW_MD5") {
        Serial.println("");
        Serial.println("================================================");
        Serial.println("FW_MD5: Command received");
        String md5 = ESP.getSketchMD5();
        Serial.print("FW_MD5: Current firmware MD5: ");
        Serial.println(md5);
        Serial.print("FW_MD5: Sending response... ");
        sendNotification("FW_MD5 " + md5);
        Serial.println("OK");
        Serial.println("================================================");
        Serial.println("");
        return;
    }

    // Check for OTA Firmware command (Allowed without Auth for specific update flow)
    if (trimmedData.startsWith("OTA_FW ")) {
        String url = trimmedData.substring(7);
        url.trim();
        
        // Validate URL
        if (!url.startsWith("http://") && !url.startsWith("https://")) {
            Serial.println("BLE: Invalid OTA URL protocol");
            sendNotification("ERROR_INVALID_URL");
            return;
        }
        
        Serial.printf("BLE: OTA Firmware request: %s\n", url.c_str());
        handleOTAFirmware(url);
        if (onOTAFirmwareReceived) {
            onOTAFirmwareReceived(url);
        }
        return;
    }
    
    // All other commands require authentication
    if (!isAuthenticated) {
        Serial.println("BLE: Command rejected - not authenticated");
        sendNotification("AUTH_REQ");
        return;
    }
    
    // Check for OTA Map command
    if (trimmedData.startsWith("OTA_MAP ")) {
        String url = trimmedData.substring(8);
        url.trim();
        
        // Validate URL
        if (!url.startsWith("http://") && !url.startsWith("https://")) {
            Serial.println("BLE: Invalid OTA URL protocol");
            sendNotification("ERROR_INVALID_URL");
            return;
        }
        
        Serial.printf("BLE: OTA Map request: %s\n", url.c_str());
        handleOTAMap(url);
        if (onOTAMapReceived) {
            onOTAMapReceived(url);
        }
        return;
    }
    
    // Check for ZOOM command
    if (trimmedData.startsWith("ZOOM ")) {
        String zoomStr = trimmedData.substring(5);
        zoomStr.trim();
        float zoomValue = zoomStr.toFloat();
        
        if (zoomValue > 0.0) {
            Serial.printf("BLE: Received zoom level: %.2f\n", zoomValue);
            if (onZoomReceived) {
                onZoomReceived(zoomValue);
            }
        } else {
            sendNotification("ERROR_INVALID_ZOOM");
        }
        return;
    }

    if (trimmedData == "UNPAIR") {
        Serial.println("BLE: Client requested unpair (forget me)");
        
        // Remove the specific token used for this session
        if (currentSessionToken.length() > 0) {
            removeToken(currentSessionToken);
            Serial.println("BLE: Removed session token from buffer");
            currentSessionToken = "";
        }
        
        // Also remove legacy bond checks if any
        if (currentClientAddress.length() > 0) {
            removeBond(currentClientAddress);
        }
        
        sendNotification("UNPAIRED");
        delay(500); // Wait for notification to send
        
        // Disconnect to enforce removal
        if (currentConnHandle != 0xFFFF && pServer) {
             pServer->disconnect(currentConnHandle);
        }
        return;
    }
    
    // Bonding management commands
    if (trimmedData == "BONDS_LIST") {
        Serial.println("BLE: Listing bonded devices");
        String bondsList = getBondedDevicesList();
        sendNotification("BONDS_LIST " + bondsList);
        return;
    }
    
    if (trimmedData == "BONDS_COUNT") {
        int count = getBondedDeviceCount();
        Serial.printf("BLE: Bonded device count: %d\n", count);
        sendNotification("BONDS_COUNT " + String(count));
        return;
    }


    
    if (trimmedData == "BONDS_CLEAR") {
        Serial.println("BLE: Clear all bonds requested");
        if (clearAllBonds()) {
            sendNotification("BONDS_CLEARED");
        } else {
            sendNotification("BONDS_CLEAR_FAILED");
        }
        return;
    }
    
    if (trimmedData.startsWith("BOND_REMOVE ")) {
        String address = trimmedData.substring(12);
        address.trim();
        Serial.printf("BLE: Remove bond requested for: %s\n", address.c_str());
        if (removeBond(address)) {
            sendNotification("BOND_REMOVED");
        } else {
            sendNotification("BOND_REMOVE_FAILED");
        }
        return;
    }
    
    if (trimmedData.startsWith("CMD_RESET")) {
        Serial.println("BLE: Reset command received");
        sendNotification("RESET_OK");
        delay(100);  // Give time for notification to send
        ESP.restart();
        return;
    }
    
    // Check for coordinates (contains comma)
    int commaIndex = trimmedData.indexOf(',');
    if (commaIndex > 0) {
        String latStr = trimmedData.substring(0, commaIndex);
        String lonStr = trimmedData.substring(commaIndex + 1);
        
        double lat = latStr.toDouble();
        double lon = lonStr.toDouble();
        
        // Basic validation
        if (lat >= -90.0 && lat <= 90.0 && lon >= -180.0 && lon <= 180.0) {
            Serial.printf("BLE: Received coordinates - Lat: %.6f, Lon: %.6f\n", lat, lon);
            if (onCoordinatesReceived) {
                onCoordinatesReceived(lat, lon);
            }
        } else {
            sendNotification("ERROR_INVALID_COORDS");
        }
        return;
    }
    
    Serial.printf("BLE: Unknown command format: %s\n", trimmedData.c_str());
    sendNotification("ERROR_UNKNOWN_CMD");
}

// Connect to WiFi
bool BLEHandler::connectToWiFi() {
    if (WiFi.status() == WL_CONNECTED) {
        Serial.println("WiFi: Already connected");
        return true;
    }
    
    Serial.printf("WiFi: Connecting to %s...\n", WIFI_SSID);
    sendNotification("WIFI_CONNECTING");
    
    WiFi.mode(WIFI_STA);
    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    
    int attempts = 0;
    while (WiFi.status() != WL_CONNECTED && attempts < 30) {
        delay(500);
        Serial.print(".");
        attempts++;
        esp_task_wdt_reset();  // Reset watchdog during WiFi connection
    }
    Serial.println();
    
    if (WiFi.status() == WL_CONNECTED) {
        Serial.printf("WiFi: Connected! IP: %s\n", WiFi.localIP().toString().c_str());
        sendNotification("WIFI_CONNECTED");
        return true;
    } else {
        Serial.println("WiFi: Connection failed");
        sendNotification("WIFI_FAILED");
        return false;
    }
}

// Handle OTA Firmware update
void BLEHandler::handleOTAFirmware(const String& url) {
    sendNotification("OTA_FW_START");
    
    if (!connectToWiFi()) {
        sendNotification("OTA_FW_FAILED");
        return;
    }
    
    Serial.printf("OTA: Starting firmware update from: %s\n", url.c_str());
    
    WiFiClient client;
    
    // Set up update callbacks for progress
    httpUpdate.onProgress([](int current, int total) {
        int percent = (current * 100) / total;
        Serial.printf("OTA Progress: %d%%\n", percent);
        if (percent % 10 == 0) {  // Send update every 10%
            bleHandler.sendNotification("OTA_PROGRESS " + String(percent));
        }
        esp_task_wdt_reset();  // Reset watchdog during OTA
    });
    
    t_httpUpdate_return ret = httpUpdate.update(client, url);
    
    switch (ret) {
        case HTTP_UPDATE_FAILED:
            Serial.printf("OTA: Firmware update failed. Error (%d): %s\n", 
                         httpUpdate.getLastError(), 
                         httpUpdate.getLastErrorString().c_str());
            sendNotification("OTA_FW_FAILED");
            break;
            
        case HTTP_UPDATE_NO_UPDATES:
            Serial.println("OTA: No updates available");
            sendNotification("OTA_FW_NO_UPDATE");
            break;
            
        case HTTP_UPDATE_OK:
            Serial.println("OTA: Firmware update successful! Rebooting...");
            sendNotification("OTA_FW_SUCCESS");
            delay(1000);
            ESP.restart();
            break;
    }
}

// Handle OTA Map update
void BLEHandler::handleOTAMap(const String& url) {
    sendNotification("OTA_MAP_START");
    
    if (!connectToWiFi()) {
        sendNotification("OTA_MAP_FAILED");
        return;
    }
    
    Serial.printf("OTA: Starting map download from: %s\n", url.c_str());
    
    // Extract filename from URL
    int lastSlash = url.lastIndexOf('/');
    String filename = "/";
    if (lastSlash >= 0) {
        filename += url.substring(lastSlash + 1);
    } else {
        filename += "map_update.mbtiles";
    }
    
    Serial.printf("OTA: Saving to SD: %s\n", filename.c_str());
    
    WiFiClient client;
    HTTPClient http;
    
    http.begin(client, url);
    http.setTimeout(30000);  // 30 second timeout
    int httpCode = http.GET();
    
    if (httpCode == HTTP_CODE_OK) {
        int contentLength = http.getSize();
        Serial.printf("OTA: Download size: %d bytes\n", contentLength);
        
        File file = SD_MMC.open(filename, FILE_WRITE);
        if (!file) {
            Serial.println("OTA: Failed to open file for writing");
            sendNotification("OTA_MAP_FAILED");
            http.end();
            return;
        }
        
        WiFiClient* stream = http.getStreamPtr();
        uint8_t buffer[4096];
        int totalRead = 0;
        int lastPercent = 0;
        
        while (http.connected() && (contentLength > 0 || contentLength == -1)) {
            size_t size = stream->available();
            if (size) {
                int c = stream->readBytes(buffer, min((size_t)sizeof(buffer), size));
                file.write(buffer, c);
                totalRead += c;
                
                if (contentLength > 0) {
                    contentLength -= c;
                    int percent = (totalRead * 100) / http.getSize();
                    if (percent != lastPercent && percent % 10 == 0) {
                        Serial.printf("OTA: Downloaded %d%%\n", percent);
                        sendNotification("OTA_PROGRESS " + String(percent));
                        lastPercent = percent;
                    }
                }
                esp_task_wdt_reset();  // Reset watchdog during download
            }
            delay(1);
        }
        
        file.close();
        Serial.printf("OTA: Map download complete. Total: %d bytes\n", totalRead);
        sendNotification("OTA_MAP_SUCCESS");
    } else {
        Serial.printf("OTA: HTTP error: %d\n", httpCode);
        sendNotification("OTA_MAP_FAILED");
    }
    
    http.end();
}


