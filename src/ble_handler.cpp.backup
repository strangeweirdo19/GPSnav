// ble_handler.cpp
#include "ble_handler.h"
#include <WiFi.h>
#include <HTTPUpdate.h>
#include <HTTPClient.h>
#include <mbedtls/base64.h>
#include <SD_MMC.h>
#include <FS.h>

// Global instance
BLEHandler bleHandler;

// Server callbacks for connection events
class ServerCallbacks: public NimBLEServerCallbacks {
    void onConnect(NimBLEServer* pServer) {
        Serial.println("BLE: Client connected");
        bleHandler.sendNotification("CONNECTED");
    }

    void onDisconnect(NimBLEServer* pServer) {
        Serial.println("BLE: Client disconnected");
        // Restart advertising
        NimBLEDevice::startAdvertising();
        Serial.println("BLE: Advertising restarted");
    }
};

// RX Characteristic callbacks for receiving data
class RxCallbacks: public NimBLECharacteristicCallbacks {
    void onWrite(NimBLECharacteristic* pCharacteristic) {
        std::string value = pCharacteristic->getValue();
        if (value.length() > 0) {
            String receivedData = String(value.c_str());
            Serial.printf("BLE RX: Received data: %s\n", receivedData.c_str());
            bleHandler.parseReceivedData(receivedData);
        }
    }
};

// Constructor
BLEHandler::BLEHandler() 
    : pServer(nullptr), pTxCharacteristic(nullptr), pRxCharacteristic(nullptr),
      deviceConnected(false), oldDeviceConnected(false) {
}

// Initialize BLE
void BLEHandler::init(const char* deviceName) {
    Serial.println("BLE: Initializing NimBLE...");
    
    // Create the BLE Device
    NimBLEDevice::init(deviceName);
    NimBLEDevice::setMTU(512); // Set MTU for larger data transfers
    
    // Create the BLE Server
    pServer = NimBLEDevice::createServer();
    pServer->setCallbacks(new ServerCallbacks());
    
    // Create the BLE Service
    NimBLEService* pService = pServer->createService(SERVICE_UUID);
    
    // Create the TX Characteristic (ESP32 -> App, Notify)
    pTxCharacteristic = pService->createCharacteristic(
        TX_CHARACTERISTIC_UUID,
        NIMBLE_PROPERTY::READ | NIMBLE_PROPERTY::NOTIFY
    );
    
    // Create the RX Characteristic (App -> ESP32, Write)
    pRxCharacteristic = pService->createCharacteristic(
        RX_CHARACTERISTIC_UUID,
        NIMBLE_PROPERTY::WRITE | NIMBLE_PROPERTY::WRITE_NR
    );
    pRxCharacteristic->setCallbacks(new RxCallbacks());
    
    // Start the service
    pService->start();
    
    // Start advertising
    NimBLEAdvertising* pAdvertising = NimBLEDevice::getAdvertising();
    pAdvertising->addServiceUUID(SERVICE_UUID);
    pAdvertising->setScanResponse(true);
    pAdvertising->setMinPreferred(0x06);  // Functions that help with iPhone connections issue
    pAdvertising->setMaxPreferred(0x12);
    
    NimBLEDevice::startAdvertising();
    Serial.printf("BLE: Service started. Device name: %s\n", deviceName);
    Serial.println("BLE: Waiting for client connection to notify...");
}

// Check if a device is connected
bool BLEHandler::isConnected() {
    return pServer->getConnectedCount() > 0;
}

// Base64 encode function using mbedtls
String BLEHandler::base64Encode(const String& input) {
    size_t outputLen = 0;
    
    // First, calculate required buffer size
    int ret = mbedtls_base64_encode(nullptr, 0, &outputLen, 
                                     (const unsigned char*)input.c_str(), 
                                     input.length());
    
    if (ret == MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL) {
        // Allocate buffer
        unsigned char* buffer = new unsigned char[outputLen];
        
        // Encode
        ret = mbedtls_base64_encode(buffer, outputLen, &outputLen,
                                    (const unsigned char*)input.c_str(),
                                    input.length());
        
        if (ret == 0) {
            String result = String((char*)buffer);
            delete[] buffer;
            return result;
        }
        delete[] buffer;
    }
    
    Serial.println("BLE: Base64 encoding failed");
    return "";
}

// Send notification to connected client (Base64 encoded)
void BLEHandler::sendNotification(const String& message) {
    if (isConnected()) {
        // Encode message in Base64 as required by the App
        String encodedMessage = base64Encode(message);
        
        if (encodedMessage.length() > 0) {
            pTxCharacteristic->setValue(encodedMessage.c_str());
            pTxCharacteristic->notify();
            Serial.printf("BLE TX: Sent notification (Base64): %s (Original: %s)\n", 
                         encodedMessage.c_str(), message.c_str());
        } else {
            Serial.println("BLE TX: Failed to encode message");
        }
    } else {
        Serial.println("BLE TX: No device connected, notification not sent");
    }
}

// Parse received data and route to appropriate handlers
void BLEHandler::parseReceivedData(const String& data) {
    String trimmedData = data;
    trimmedData.trim();
    
    // Check for OTA Firmware command
    if (trimmedData.startsWith("OTA_FW ")) {
        String url = trimmedData.substring(7); // Extract URL after "OTA_FW "
        url.trim();
        Serial.printf("BLE: OTA Firmware request: %s\n", url.c_str());
        handleOTAFirmware(url);
        if (onOTAFirmwareReceived) {
            onOTAFirmwareReceived(url);
        }
        return;
    }
    
    // Check for OTA Map command
    if (trimmedData.startsWith("OTA_MAP ")) {
        String url = trimmedData.substring(8); // Extract URL after "OTA_MAP "
        url.trim();
        Serial.printf("BLE: OTA Map request: %s\n", url.c_str());
        handleOTAMap(url);
        if (onOTAMapReceived) {
            onOTAMapReceived(url);
        }
        return;
    }
    
    // Check for coordinates (contains comma)
    int commaIndex = trimmedData.indexOf(',');
    if (commaIndex > 0) {
        String latStr = trimmedData.substring(0, commaIndex);
        String lonStr = trimmedData.substring(commaIndex + 1);
        
        double lat = latStr.toDouble();
        double lon = lonStr.toDouble();
        
        Serial.printf("BLE: Received coordinates - Lat: %.6f, Lon: %.6f\n", lat, lon);
        
        if (onCoordinatesReceived) {
            onCoordinatesReceived(lat, lon);
        }
        return;
    }
    
    // Try to parse as zoom level (single number)
    float zoomValue = trimmedData.toFloat();
    if (zoomValue > 0.0) {
        Serial.printf("BLE: Received zoom level: %.2f\n", zoomValue);
        
        if (onZoomReceived) {
            onZoomReceived(zoomValue);
        }
        return;
    }
    
    Serial.printf("BLE: Unknown command format: %s\n", trimmedData.c_str());
}

// Connect to WiFi
bool BLEHandler::connectToWiFi() {
    if (WiFi.status() == WL_CONNECTED) {
        Serial.println("WiFi: Already connected");
        return true;
    }
    
    Serial.printf("WiFi: Connecting to %s...\n", WIFI_SSID);
    sendNotification("WIFI_CONNECTING");
    
    WiFi.mode(WIFI_STA);
    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    
    int attempts = 0;
    while (WiFi.status() != WL_CONNECTED && attempts < 30) {
        delay(500);
        Serial.print(".");
        attempts++;
    }
    Serial.println();
    
    if (WiFi.status() == WL_CONNECTED) {
        Serial.printf("WiFi: Connected! IP: %s\n", WiFi.localIP().toString().c_str());
        sendNotification("WIFI_CONNECTED");
        return true;
    } else {
        Serial.println("WiFi: Connection failed");
        sendNotification("WIFI_FAILED");
        return false;
    }
}

// Handle OTA Firmware update
void BLEHandler::handleOTAFirmware(const String& url) {
    sendNotification("OTA_FW_START");
    
    if (!connectToWiFi()) {
        sendNotification("OTA_FW_FAILED");
        return;
    }
    
    Serial.printf("OTA: Starting firmware update from: %s\n", url.c_str());
    
    WiFiClient client;
    t_httpUpdate_return ret = httpUpdate.update(client, url);
    
    switch (ret) {
        case HTTP_UPDATE_FAILED:
            Serial.printf("OTA: Firmware update failed. Error (%d): %s\n", 
                         httpUpdate.getLastError(), 
                         httpUpdate.getLastErrorString().c_str());
            sendNotification("OTA_FW_FAILED");
            break;
            
        case HTTP_UPDATE_NO_UPDATES:
            Serial.println("OTA: No updates available");
            sendNotification("OTA_FW_NO_UPDATE");
            break;
            
        case HTTP_UPDATE_OK:
            Serial.println("OTA: Firmware update successful! Rebooting...");
            sendNotification("OTA_FW_SUCCESS");
            delay(1000);
            ESP.restart();
            break;
    }
}

// Handle OTA Map update
void BLEHandler::handleOTAMap(const String& url) {
    sendNotification("OTA_MAP_START");
    
    if (!connectToWiFi()) {
        sendNotification("OTA_MAP_FAILED");
        return;
    }
    
    Serial.printf("OTA: Starting map download from: %s\n", url.c_str());
    
    // Extract filename from URL
    int lastSlash = url.lastIndexOf('/');
    String filename = "/";
    if (lastSlash >= 0) {
        filename += url.substring(lastSlash + 1);
    } else {
        filename += "map_update.mbtiles";
    }
    
    Serial.printf("OTA: Saving to SD: %s\n", filename.c_str());
    
    WiFiClient client;
    HTTPClient http;
    
    http.begin(client, url);
    int httpCode = http.GET();
    
    if (httpCode == HTTP_CODE_OK) {
        // Get file size
        int contentLength = http.getSize();
        Serial.printf("OTA: Download size: %d bytes\n", contentLength);
        
        // Open file for writing on SD card
        File file = SD_MMC.open(filename, FILE_WRITE);
        if (!file) {
            Serial.println("OTA: Failed to open file for writing");
            sendNotification("OTA_MAP_FAILED");
            http.end();
            return;
        }
        
        // Download and save
        WiFiClient* stream = http.getStreamPtr();
        uint8_t buffer[4096];
        int bytesRead = 0;
        int totalRead = 0;
        
        while (http.connected() && (contentLength > 0 || contentLength == -1)) {
            size_t size = stream->available();
            if (size) {
                int c = stream->readBytes(buffer, min((size_t)sizeof(buffer), size));
                file.write(buffer, c);
                totalRead += c;
                
                if (contentLength > 0) {
                    contentLength -= c;
                    // Send progress update every 100KB
                    if (totalRead / 102400 > bytesRead / 102400) {
                        Serial.printf("OTA: Downloaded %d bytes\n", totalRead);
                        String progress = "MAP_PROGRESS_" + String(totalRead);
                        sendNotification(progress);
                    }
                    bytesRead = totalRead;
                }
            }
            delay(1);
        }
        
        file.close();
        Serial.printf("OTA: Map download complete. Total: %d bytes\n", totalRead);
        sendNotification("OTA_MAP_SUCCESS");
    } else {
        Serial.printf("OTA: HTTP error: %d\n", httpCode);
        sendNotification("OTA_MAP_FAILED");
    }
    
    http.end();
}
